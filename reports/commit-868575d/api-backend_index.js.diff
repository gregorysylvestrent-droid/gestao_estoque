diff --git a/api-backend/index.js b/api-backend/index.js
index eaf2e7f..20b4826 100644
--- a/api-backend/index.js
+++ b/api-backend/index.js
@@ -1,4 +1,4 @@
-﻿import express from 'express';
+import express from 'express';
 import cors from 'cors';
 import pg from 'pg';
 import dotenv from 'dotenv';
@@ -22,13 +22,17 @@ const DATA_DIR = path.join(__dirname, 'data');
 const JWT_SECRET = process.env.JWT_SECRET || 'dev-only-secret-change-me';
 const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '8h';
 const DB_HEALTHCHECK_INTERVAL_MS = Number(process.env.DB_HEALTHCHECK_INTERVAL_MS || 10000);
+const PURCHASE_ORDER_RETENTION_MS = 24 * 60 * 60 * 1000;
+const PO_RETENTION_CLEANUP_INTERVAL_MS = Number(
+  process.env.PO_RETENTION_CLEANUP_INTERVAL_MS || 60 * 1000
+);
 
 const PASSWORD_PREFIX = 'pbkdf2';
 const PASSWORD_ITERATIONS = 310000;
 const PASSWORD_KEYLEN = 32;
 const PASSWORD_DIGEST = 'sha256';
 
-const RESERVED_QUERY_KEYS = new Set(['select', 'order', 'limit', 'offset']);
+const RESERVED_QUERY_KEYS = new Set(['select', 'order', 'limit', 'offset', 'source_module']);
 
 const TABLE_WHITELIST = [
   'users',
@@ -38,6 +42,12 @@ const TABLE_WHITELIST = [
   'cyclic_counts',
   'vendors',
   'vehicles',
+  'fleet_vehicles',
+  'fleet_people',
+  'fleet_fines',
+  'fleet_tachograph_checks',
+  'fleet_rntrc_records',
+  'fleet_fiscal_obligations',
   'purchase_orders',
   'movements',
   'notifications',
@@ -52,8 +62,67 @@ const TABLE_COLUMNS = {
   inventory: ['sku', 'name', 'location', 'batch', 'expiry', 'quantity', 'status', 'image_url', 'category', 'min_qty', 'max_qty', 'unit', 'lead_time', 'safety_stock', 'abc_category', 'last_counted_at', 'warehouse_id', 'created_at'],
   cyclic_batches: ['id', 'status', 'scheduled_date', 'completed_at', 'accuracy_rate', 'total_items', 'divergent_items', 'warehouse_id', 'created_at'],
   cyclic_counts: ['id', 'batch_id', 'sku', 'expected_qty', 'counted_qty', 'status', 'notes', 'counted_at', 'warehouse_id'],
-  vendors: ['id', 'name', 'cnpj', 'category', 'contact', 'email', 'status', 'created_at'],
+  vendors: [
+    'id',
+    'id_fornecedor',
+    'razao_social',
+    'nome_fantasia',
+    'cnpj',
+    'telefone',
+    'name',
+    'category',
+    'contact',
+    'email',
+    'status',
+    'created_at',
+  ],
   vehicles: ['plate', 'model', 'type', 'status', 'last_maintenance', 'cost_center', 'created_at'],
+  fleet_vehicles: [
+    'placa',
+    'renavam',
+    'chassi',
+    'classe',
+    'cor',
+    'ano_modelo',
+    'ano_fabricacao',
+    'cidade',
+    'estado',
+    'proprietario',
+    'cod_centro_custo',
+    'desc_centro_custo',
+    'desc_modelo',
+    'desc_marca',
+    'desc_combustivel',
+    'km_atual',
+    'km_anterior',
+    'dta_ult_manutencao',
+    'dta_prox_manutencao',
+    'km_prox_manutencao',
+    'gestao_multa',
+    'setor_veiculo',
+    'responsavel_veiculo',
+    'created_at',
+  ],
+  fleet_people: [
+    'cpf',
+    'matricula',
+    'nome_completo',
+    'id_perfil',
+    'id_funcao',
+    'cod_centro_custo',
+    'cnh',
+    'categoria',
+    'validade_cnh',
+    'toxico_venc',
+    'telefone',
+    'email',
+    'status',
+    'created_at',
+  ],
+  fleet_fines: ['id', 'placa', 'ain', 'data', 'hora', 'local', 'valor', 'gravidade', 'enquadramento', 'condutor', 'status', 'created_at'],
+  fleet_tachograph_checks: ['id', 'placa', 'num_certificado', 'dta_afericao', 'dta_vencimento', 'valor_taxa', 'status', 'created_at'],
+  fleet_rntrc_records: ['id', 'razao_social', 'documento', 'rntrc', 'categoria', 'vencimento', 'status', 'created_at'],
+  fleet_fiscal_obligations: ['id', 'placa', 'tipo', 'exercicio', 'vencimento', 'valor', 'status', 'created_at'],
   purchase_orders: ['id', 'vendor', 'request_date', 'status', 'priority', 'total', 'requester', 'items', 'quotes', 'selected_quote_id', 'sent_to_vendor_at', 'received_at', 'quotes_added_at', 'approved_at', 'rejected_at', 'vendor_order_number', 'approval_history', 'plate', 'cost_center', 'warehouse_id', 'created_at'],
   movements: ['id', 'sku', 'product_name', 'type', 'quantity', 'timestamp', 'user', 'location', 'reason', 'order_id', 'warehouse_id'],
   notifications: ['id', 'title', 'message', 'type', 'read', 'user_id', 'created_at'],
@@ -84,6 +153,12 @@ const TABLE_JSON_COLUMNS = {
 const TABLE_TIMESTAMP_COLUMNS = {
   users: ['last_access'],
   vehicles: ['last_maintenance'],
+  fleet_vehicles: ['dta_ult_manutencao', 'dta_prox_manutencao', 'created_at'],
+  fleet_people: ['validade_cnh', 'toxico_venc', 'created_at'],
+  fleet_fines: ['data', 'created_at'],
+  fleet_tachograph_checks: ['dta_afericao', 'dta_vencimento', 'created_at'],
+  fleet_rntrc_records: ['vencimento', 'created_at'],
+  fleet_fiscal_obligations: ['vencimento', 'created_at'],
   inventory: ['last_counted_at'],
   movements: ['timestamp'],
   purchase_orders: ['request_date', 'sent_to_vendor_at', 'received_at', 'quotes_added_at', 'approved_at', 'rejected_at'],
@@ -195,18 +270,41 @@ const allowedOrigins = (process.env.CORS_ORIGIN || '')
   .map((origin) => origin.trim())
   .filter(Boolean);
 
+// Always allow local development origins
+if (!isProd) {
+  const devOrigins = [
+    'http://localhost:3000',
+    'http://localhost:3001',
+    'http://localhost:3002',
+    'http://127.0.0.1:3000',
+    'http://127.0.0.1:3001',
+    'http://127.0.0.1:3002'
+  ];
+  devOrigins.forEach(origin => {
+    if (!allowedOrigins.includes(origin)) {
+      allowedOrigins.push(origin);
+    }
+  });
+}
+
 app.use(helmet({ contentSecurityPolicy: false }));
 app.use(
   cors({
-    origin: allowedOrigins.length
-      ? (origin, callback) => {
-          if (!origin || allowedOrigins.includes(origin)) {
-            callback(null, true);
-            return;
-          }
-          callback(new Error('Not allowed by CORS'));
-        }
-      : true,
+    origin: (origin, callback) => {
+      // Allow all origins in development/non-production mode
+      if (!isProd) {
+        callback(null, true);
+        return;
+      }
+
+      // In production, strictly check against allowed origins
+      if (allowedOrigins.length === 0 || !origin || allowedOrigins.includes(origin)) {
+        callback(null, true);
+        return;
+      }
+      
+      callback(new Error('Not allowed by CORS'));
+    },
     credentials: true,
   })
 );
@@ -315,6 +413,197 @@ const parseDateFilter = (dateValue) => {
   return parsed.toISOString();
 };
 
+const WRITE_RESTRICTED_TABLES = new Set(['vehicles']);
+const DB_TRIGGER_AUDITED_TABLES = new Set(['vendors', 'inventory', 'fleet_vehicles']);
+const FLEET_WRITE_ALLOWED_SOURCE_MODULES = new Set(['gestao_frota', 'frota', 'oficina']);
+const VENDOR_RAZAO_SOCIAL_MAX_LENGTH = 150;
+const VENDOR_NOME_FANTASIA_MAX_LENGTH = 100;
+const INVENTORY_DESCRIPTION_MAX_LENGTH = 255;
+
+const normalizeDigits = (value) => String(value ?? '').replace(/\D+/g, '');
+const normalizeWhitespace = (value) => String(value ?? '').replace(/\s+/g, ' ').trim();
+const normalizeVendorStatus = (value) =>
+  String(value || '').toLowerCase() === 'bloqueado' ? 'Bloqueado' : 'Ativo';
+
+const normalizeCnpj = (value) => normalizeDigits(value).slice(0, 14);
+
+const isValidCnpj = (value) => {
+  const cnpj = normalizeCnpj(value);
+  if (cnpj.length !== 14) return false;
+  if (/^(\d)\1{13}$/.test(cnpj)) return false;
+
+  const calcDigit = (base, factor) => {
+    let total = 0;
+    for (const digit of base) {
+      total += Number(digit) * factor;
+      factor -= 1;
+      if (factor < 2) factor = 9;
+    }
+    const remainder = total % 11;
+    return remainder < 2 ? 0 : 11 - remainder;
+  };
+
+  const firstBase = cnpj.slice(0, 12);
+  const firstDigit = calcDigit(firstBase, 5);
+  const secondDigit = calcDigit(`${firstBase}${firstDigit}`, 6);
+
+  return cnpj === `${firstBase}${firstDigit}${secondDigit}`;
+};
+
+const normalizePhone = (value) => {
+  const digits = normalizeDigits(value);
+  if (!digits) return '';
+  if (digits.length === 10) return `(${digits.slice(0, 2)}) ${digits.slice(2, 6)}-${digits.slice(6)}`;
+  if (digits.length === 11) return `(${digits.slice(0, 2)}) ${digits.slice(2, 7)}-${digits.slice(7)}`;
+  return normalizeWhitespace(value);
+};
+
+const assertMaxLength = (value, maxLength, label) => {
+  const normalized = String(value || '');
+  if (normalized.length > maxLength) {
+    throw new Error(`${label} deve ter no maximo ${maxLength} caracteres`);
+  }
+};
+
+const getVendorComparableName = (row) =>
+  normalizeWhitespace(row?.razao_social || row?.name || '').toLowerCase();
+const getVendorComparableCnpj = (row) => normalizeCnpj(row?.cnpj || '');
+
+const normalizeVendorRow = (row, fallbackId = null) => {
+  const { id_fornecedor: _ignoredVendorId, ...safeRow } = row || {};
+  const razaoSocial = normalizeWhitespace(row?.razao_social || row?.name || '');
+  const nomeFantasia = normalizeWhitespace(row?.nome_fantasia || '');
+  const cnpj = normalizeCnpj(row?.cnpj || '');
+  const telefone = normalizePhone(row?.telefone || row?.contact || '');
+  const status = normalizeVendorStatus(row?.status);
+  const id = normalizeWhitespace(row?.id || fallbackId || '');
+
+  if (!id) {
+    throw new Error('ID do fornecedor e obrigatorio');
+  }
+
+  if (!razaoSocial) {
+    throw new Error('Razao social e obrigatoria');
+  }
+
+  assertMaxLength(razaoSocial, VENDOR_RAZAO_SOCIAL_MAX_LENGTH, 'Razao social');
+  assertMaxLength(nomeFantasia, VENDOR_NOME_FANTASIA_MAX_LENGTH, 'Nome fantasia');
+
+  if (!cnpj || !isValidCnpj(cnpj)) {
+    throw new Error('CNPJ invalido');
+  }
+
+  return {
+    ...safeRow,
+    id,
+    razao_social: razaoSocial,
+    nome_fantasia: nomeFantasia || null,
+    cnpj,
+    telefone: telefone || null,
+    name: razaoSocial,
+    contact: telefone || nomeFantasia || null,
+    status,
+  };
+};
+
+const ensureNoVendorDuplicatesInMemory = (rows, existingRows = [], ignoreIds = new Set()) => {
+  const seenName = new Set();
+  const seenCnpj = new Set();
+
+  for (const row of rows) {
+    const id = String(row?.id || '');
+    const comparableName = getVendorComparableName(row);
+    const comparableCnpj = getVendorComparableCnpj(row);
+
+    if (comparableName) {
+      if (seenName.has(comparableName)) {
+        throw new Error(`Razao social duplicada no lote: ${row.razao_social}`);
+      }
+      seenName.add(comparableName);
+    }
+
+    if (comparableCnpj) {
+      if (seenCnpj.has(comparableCnpj)) {
+        throw new Error(`CNPJ duplicado no lote: ${row.cnpj}`);
+      }
+      seenCnpj.add(comparableCnpj);
+    }
+
+    for (const existing of existingRows) {
+      const existingId = String(existing?.id || '');
+      if (existingId && (existingId === id || ignoreIds.has(existingId))) continue;
+
+      const existingName = getVendorComparableName(existing);
+      const existingCnpj = getVendorComparableCnpj(existing);
+
+      if (comparableName && existingName && comparableName === existingName) {
+        throw new Error(`Razao social ja cadastrada: ${row.razao_social}`);
+      }
+
+      if (comparableCnpj && existingCnpj && comparableCnpj === existingCnpj) {
+        throw new Error(`CNPJ ja cadastrado: ${row.cnpj}`);
+      }
+    }
+  }
+};
+
+const findVendorConflictInDb = async (db, row, ignoreId = null) => {
+  const comparableName = getVendorComparableName(row);
+  const comparableCnpj = getVendorComparableCnpj(row);
+  const clauses = [];
+  const values = [];
+
+  if (comparableName) {
+    values.push(comparableName);
+    clauses.push(
+      `lower(regexp_replace(btrim(coalesce(razao_social, name, '')), '\\s+', ' ', 'g')) = $${values.length}`
+    );
+  }
+
+  if (comparableCnpj) {
+    values.push(comparableCnpj);
+    clauses.push(`regexp_replace(coalesce(cnpj, ''), '[^0-9]', '', 'g') = $${values.length}`);
+  }
+
+  if (clauses.length === 0) return null;
+
+  let query = `SELECT id, razao_social, name, cnpj FROM vendors WHERE (${clauses.join(' OR ')})`;
+  if (ignoreId) {
+    values.push(ignoreId);
+    query += ` AND id <> $${values.length}`;
+  }
+  query += ' LIMIT 1';
+
+  const result = await db.query(query, values);
+  return result.rows?.[0] || null;
+};
+
+const getSourceModuleFromRequest = (req) =>
+  normalizeWhitespace(toScalar(req?.query?.source_module || '')).toLowerCase();
+
+const ensureFleetWriteSourceModule = (table, req, res) => {
+  if (table !== 'fleet_vehicles') return true;
+
+  const sourceModule = getSourceModuleFromRequest(req);
+  if (!sourceModule) {
+    res.status(400).json({
+      data: null,
+      error: 'source_module obrigatorio para escrita em fleet_vehicles',
+    });
+    return false;
+  }
+
+  if (!FLEET_WRITE_ALLOWED_SOURCE_MODULES.has(sourceModule)) {
+    res.status(403).json({
+      data: null,
+      error: `Modulo sem permissao para escrita em fleet_vehicles: ${sourceModule}`,
+    });
+    return false;
+  }
+
+  return true;
+};
+
 const includesText = (source, term) => String(source || '').toLowerCase().includes(String(term || '').toLowerCase());
 const normalizePlateToken = (value) => String(value || '').replace(/[^a-z0-9]/gi, '').toLowerCase();
 
@@ -494,9 +783,61 @@ const normalizeRowsByTable = (table, rows) => {
     return rows.map((row) => normalizePurchaseOrderRecord(row));
   }
 
+  if (table === 'vendors') {
+    return rows.map((row) => {
+      const razaoSocial = normalizeWhitespace(row?.razao_social || row?.name || '');
+      const nomeFantasia = normalizeWhitespace(row?.nome_fantasia || '');
+      const telefone = normalizePhone(row?.telefone || row?.contact || '');
+      return {
+        ...row,
+        razao_social: razaoSocial,
+        nome_fantasia: nomeFantasia || null,
+        telefone: telefone || null,
+        name: razaoSocial,
+        contact: telefone || nomeFantasia || null,
+        cnpj: normalizeCnpj(row?.cnpj || ''),
+        status: normalizeVendorStatus(row?.status),
+      };
+    });
+  }
+
   return rows;
 };
 
+const mapFleetVehicleToLegacyVehicle = (row) => ({
+  plate: String(row?.placa || row?.plate || '')
+    .trim()
+    .toUpperCase(),
+  model: normalizeWhitespace(row?.desc_modelo || row?.model || ''),
+  type: normalizeWhitespace(row?.classe || row?.type || ''),
+  status: normalizeWhitespace(row?.status || '') || 'Disponivel',
+  last_maintenance: row?.dta_ult_manutencao || row?.last_maintenance || null,
+  cost_center: normalizeWhitespace(
+    row?.cod_centro_custo || row?.cost_center || row?.desc_centro_custo || ''
+  ),
+  created_at: row?.created_at || null,
+});
+
+const getCentralVehicleRows = async () => {
+  if (dbConnected) {
+    const result = await pool.query('SELECT * FROM fleet_vehicles');
+    return { rows: result.rows, mode: 'db' };
+  }
+
+  const fleetRows = readJson('fleet_vehicles');
+  if (Array.isArray(fleetRows) && fleetRows.length > 0) {
+    return { rows: fleetRows, mode: 'json-fleet' };
+  }
+
+  return { rows: readJson('vehicles'), mode: 'json-legacy' };
+};
+
+const readCentralVehiclesAsLegacy = async () => {
+  const source = await getCentralVehicleRows();
+  const rows = source.rows.map((row) => mapFleetVehicleToLegacyVehicle(row)).filter((row) => row.plate);
+  return { rows, mode: source.mode };
+};
+
 const normalizeJsonColumnValueForDb = (value) => {
   if (value === null || value === undefined) return value;
   if (typeof value === 'string') return value;
@@ -691,6 +1032,12 @@ const ENTITY_ID_FIELD = {
   cyclic_counts: 'id',
   vendors: 'id',
   vehicles: 'plate',
+  fleet_vehicles: 'placa',
+  fleet_people: 'cpf',
+  fleet_fines: 'id',
+  fleet_tachograph_checks: 'id',
+  fleet_rntrc_records: 'id',
+  fleet_fiscal_obligations: 'id',
   purchase_orders: 'id',
   movements: 'id',
   notifications: 'id',
@@ -771,6 +1118,153 @@ const persistAuditLogs = async (entries, db = null) => {
   }
 };
 
+const setDbAuditContext = async (db, { actor, actorId, module }) => {
+  if (!db) return;
+  await db.query(
+    `
+      SELECT
+        set_config('app.audit_actor', $1, true),
+        set_config('app.audit_actor_id', $2, true),
+        set_config('app.audit_module', $3, true)
+    `,
+    [String(actor || ''), actorId ? String(actorId) : '', String(module || '')]
+  );
+};
+
+let poRetentionCleanupInFlight = false;
+
+const isDeliveredPoExpired = (row, cutoffTimeMs) => {
+  if (!row || typeof row !== 'object') return false;
+  if (String(row.status || '') !== 'recebido') return false;
+  if (!row.received_at) return false;
+
+  const receivedAt = new Date(row.received_at);
+  if (Number.isNaN(receivedAt.getTime())) return false;
+  return receivedAt.getTime() <= cutoffTimeMs;
+};
+
+const buildPoRetentionAuditLog = (row, cutoffIso, mode) =>
+  buildAuditLog({
+    module: 'purchase_orders',
+    action: 'delete',
+    entity: 'purchase_orders',
+    entityId: getEntityId('purchase_orders', row),
+    actor: 'Sistema',
+    actorId: null,
+    warehouseId: row?.warehouse_id || null,
+    beforeData: row,
+    afterData: null,
+    meta: {
+      reason: 'retention_cleanup_after_24h_recebido',
+      retention_hours: 24,
+      received_at: row?.received_at || null,
+      cutoff_at: cutoffIso,
+      mode,
+    },
+  });
+
+const runPurchaseOrdersRetentionCleanup = async () => {
+  if (poRetentionCleanupInFlight) return;
+  poRetentionCleanupInFlight = true;
+
+  const cutoffTimeMs = Date.now() - PURCHASE_ORDER_RETENTION_MS;
+  const cutoffIso = new Date(cutoffTimeMs).toISOString();
+
+  try {
+    if (!dbConnected) {
+      const currentRows = normalizeRowsByTable('purchase_orders', readJson('purchase_orders'));
+      if (!Array.isArray(currentRows) || currentRows.length === 0) return;
+
+      const rowsToDelete = [];
+      const rowsToKeep = [];
+
+      currentRows.forEach((row) => {
+        if (isDeliveredPoExpired(row, cutoffTimeMs)) {
+          rowsToDelete.push(row);
+          return;
+        }
+        rowsToKeep.push(row);
+      });
+
+      if (rowsToDelete.length === 0) return;
+
+      writeJson('purchase_orders', rowsToKeep);
+      await persistAuditLogs(rowsToDelete.map((row) => buildPoRetentionAuditLog(row, cutoffIso, 'json')));
+      console.log(`[PO RETENTION] ${rowsToDelete.length} pedido(s) entregue(s) removido(s) em modo JSON.`);
+      return;
+    }
+
+    let client;
+    try {
+      client = await pool.connect();
+      await client.query('BEGIN');
+      await setDbAuditContext(client, {
+        actor: 'Sistema',
+        actorId: null,
+        module: 'purchase_orders',
+      });
+
+      const deleteResult = await client.query(
+        `
+          DELETE FROM purchase_orders
+          WHERE status = 'recebido'
+            AND received_at IS NOT NULL
+            AND received_at <= $1
+          RETURNING *
+        `,
+        [cutoffIso]
+      );
+
+      const deletedRows = normalizeRowsByTable('purchase_orders', deleteResult.rows);
+      if (deletedRows.length > 0) {
+        const auditEntries = deletedRows.map((row) => buildPoRetentionAuditLog(row, cutoffIso, 'db'));
+        await persistAuditLogs(auditEntries, client);
+      }
+
+      await client.query('COMMIT');
+      if (deletedRows.length > 0) {
+        console.log(`[PO RETENTION] ${deletedRows.length} pedido(s) entregue(s) removido(s) em modo DB.`);
+      }
+    } catch (err) {
+      if (client) {
+        try {
+          await client.query('ROLLBACK');
+        } catch {
+          // noop
+        }
+      }
+      markDbDisconnectedIfNeeded(err);
+      console.warn(`[PO RETENTION] cleanup failed: ${getErrorReason(err)}`);
+    } finally {
+      if (client) client.release();
+    }
+  } finally {
+    poRetentionCleanupInFlight = false;
+  }
+};
+
+const sendUniqueConstraintConflict = (res, err) => {
+  if (String(err?.code || '') !== '23505') return false;
+
+  const detail = String(err?.detail || '');
+  let message = 'Registro duplicado. Revise os campos unicos.';
+
+  if (detail.includes('(sku)')) {
+    message = 'Codigo item (SKU) ja cadastrado.';
+  } else if (detail.includes('(id_fornecedor)')) {
+    message = 'ID de fornecedor ja cadastrado.';
+  } else if (detail.toLowerCase().includes('cnpj')) {
+    message = 'CNPJ ja cadastrado.';
+  } else if (detail.toLowerCase().includes('razao_social') || detail.toLowerCase().includes('name')) {
+    message = 'Razao social ja cadastrada.';
+  } else if (detail.toLowerCase().includes('placa') || detail.toLowerCase().includes('plate')) {
+    message = 'Placa ja cadastrada.';
+  }
+
+  res.status(409).json({ data: null, error: message });
+  return true;
+};
+
 app.get('/health', (_req, res) => {
   res.json({
     status: 'ok',
@@ -1455,6 +1949,27 @@ app.get('/:table/count', authenticate, async (req, res) => {
     return;
   }
 
+  if (table === 'vehicles') {
+    try {
+      const { rows } = await readCentralVehiclesAsLegacy();
+      const filteredRows = applyFiltersToJsonRows(rows, filters);
+      res.json({ data: { total: filteredRows.length }, error: null });
+    } catch (err) {
+      markDbDisconnectedIfNeeded(err);
+      try {
+        const fleetRows = readJson('fleet_vehicles');
+        const fallbackRows = (Array.isArray(fleetRows) && fleetRows.length > 0 ? fleetRows : readJson('vehicles'))
+          .map((row) => mapFleetVehicleToLegacyVehicle(row))
+          .filter((row) => row.plate);
+        const filteredRows = applyFiltersToJsonRows(fallbackRows, filters);
+        res.json({ data: { total: filteredRows.length }, error: null });
+      } catch {
+        sendServerError(res, err);
+      }
+    }
+    return;
+  }
+
   if (!dbConnected) {
     let rows = normalizeRowsByTable(table, readJson(table));
     rows = applyFiltersToJsonRows(rows, filters);
@@ -1487,6 +2002,9 @@ app.get('/:table/count', authenticate, async (req, res) => {
 
 app.get('/:table', authenticate, async (req, res) => {
   const { table } = req.params;
+  const actor = String(req.auth?.email || req.auth?.sub || 'Sistema');
+  const actorId = req.auth?.sub ? String(req.auth.sub) : null;
+  const sourceModule = normalizeWhitespace(toScalar(req.query.source_module));
 
   if (!validateTable(table)) {
     res.status(403).json({ data: null, error: 'Tabela nao permitida' });
@@ -1517,12 +2035,81 @@ app.get('/:table', authenticate, async (req, res) => {
     return;
   }
 
+  if (table === 'vehicles') {
+    try {
+      const { rows: sourceRows, mode } = await readCentralVehiclesAsLegacy();
+      let rows = applyFiltersToJsonRows(sourceRows, filters);
+      rows = applyOrderToJsonRows(rows, order);
+      rows = applyPaginationToJsonRows(rows, limit, offset || 0);
+
+      if (sourceModule) {
+        const auditEntry = buildAuditLog({
+          module: sourceModule,
+          action: 'lookup',
+          entity: 'fleet_vehicles',
+          entityId: filters?.plate || null,
+          actor,
+          actorId,
+          warehouseId: null,
+          beforeData: null,
+          afterData: null,
+          meta: {
+            source_module: sourceModule,
+            filters,
+            total_returned: rows.length,
+            mode,
+          },
+        });
+        await persistAuditLogs([auditEntry], mode === 'db' ? pool : null);
+      }
+
+      res.json({ data: sanitizeResponse(rows), error: null });
+    } catch (err) {
+      markDbDisconnectedIfNeeded(err);
+      try {
+        const fleetRows = readJson('fleet_vehicles');
+        let rows = (Array.isArray(fleetRows) && fleetRows.length > 0 ? fleetRows : readJson('vehicles'))
+          .map((row) => mapFleetVehicleToLegacyVehicle(row))
+          .filter((row) => row.plate);
+        rows = applyFiltersToJsonRows(rows, filters);
+        rows = applyOrderToJsonRows(rows, order);
+        rows = applyPaginationToJsonRows(rows, limit, offset || 0);
+        res.json({ data: sanitizeResponse(rows), error: null });
+      } catch {
+        sendServerError(res, err);
+      }
+    }
+    return;
+  }
+
   if (!dbConnected) {
     let rows = normalizeRowsByTable(table, readJson(table));
     rows = applyFiltersToJsonRows(rows, filters);
     rows = applyOrderToJsonRows(rows, order);
     rows = applyPaginationToJsonRows(rows, limit, offset || 0);
 
+    if (table === 'fleet_vehicles' && sourceModule) {
+      await persistAuditLogs([
+        buildAuditLog({
+          module: sourceModule,
+          action: 'lookup',
+          entity: 'fleet_vehicles',
+          entityId: filters?.placa || null,
+          actor,
+          actorId,
+          warehouseId: null,
+          beforeData: null,
+          afterData: null,
+          meta: {
+            source_module: sourceModule,
+            filters,
+            total_returned: rows.length,
+            mode: 'json',
+          },
+        }),
+      ]);
+    }
+
     res.json({ data: sanitizeResponse(rows), error: null });
     return;
   }
@@ -1557,6 +2144,32 @@ app.get('/:table', authenticate, async (req, res) => {
 
     const result = await pool.query(query, values);
     const rows = normalizeRowsByTable(table, result.rows);
+
+    if (table === 'fleet_vehicles' && sourceModule) {
+      await persistAuditLogs(
+        [
+          buildAuditLog({
+            module: sourceModule,
+            action: 'lookup',
+            entity: 'fleet_vehicles',
+            entityId: filters?.placa || null,
+            actor,
+            actorId,
+            warehouseId: null,
+            beforeData: null,
+            afterData: null,
+            meta: {
+              source_module: sourceModule,
+              filters,
+              total_returned: rows.length,
+              mode: 'db',
+            },
+          }),
+        ],
+        pool
+      );
+    }
+
     res.json({ data: sanitizeResponse(rows), error: null });
   } catch (err) {
     markDbDisconnectedIfNeeded(err);
@@ -1574,6 +2187,18 @@ app.post('/:table', authenticate, async (req, res) => {
     return;
   }
 
+  if (WRITE_RESTRICTED_TABLES.has(table)) {
+    res.status(403).json({
+      data: null,
+      error: 'Escrita bloqueada nesta tabela. Use a base central em fleet_vehicles.',
+    });
+    return;
+  }
+
+  if (!ensureFleetWriteSourceModule(table, req, res)) {
+    return;
+  }
+
   const payload = req.body;
   const rows = Array.isArray(payload) ? payload : [payload];
 
@@ -1587,30 +2212,183 @@ app.post('/:table', authenticate, async (req, res) => {
     return;
   }
 
-  const preparedRows = rows.map((row) => {
-    const nextRow = { ...row };
-    if (table === 'users' && 'password' in nextRow) {
-      nextRow.password = ensurePasswordHash(nextRow.password);
-    }
-    if (table === 'inventory') {
-      const normalizedSku = typeof nextRow.sku === 'string' ? nextRow.sku.trim() : '';
-      nextRow.sku = normalizedSku || generateInventorySku();
-      if (!nextRow.status) nextRow.status = 'disponivel';
-      if (!nextRow.location) nextRow.location = 'DOCA-01';
-      if (nextRow.quantity === null || nextRow.quantity === undefined || Number.isNaN(Number(nextRow.quantity))) {
-        nextRow.quantity = 0;
+  let vendorLocalSequence = 0;
+  let preparedRows = [];
+  try {
+    preparedRows = rows.map((row, index) => {
+      const nextRow = { ...row };
+      if (table === 'users' && 'password' in nextRow) {
+        nextRow.password = ensurePasswordHash(nextRow.password);
       }
-      if (!nextRow.warehouse_id) nextRow.warehouse_id = 'ARMZ28';
-    }
-    if (table === 'cyclic_counts') {
-      if (!nextRow.id) nextRow.id = crypto.randomUUID();
-      if (!nextRow.status) nextRow.status = 'pendente';
+      if (table === 'inventory') {
+        const normalizedSku = typeof nextRow.sku === 'string' ? nextRow.sku.trim() : '';
+        if (!normalizedSku) {
+          throw new Error('Codigo item (SKU) obrigatorio');
+        }
+        nextRow.sku = normalizedSku.toUpperCase();
+        nextRow.name = normalizeWhitespace(nextRow.name);
+        if (!nextRow.name) {
+          throw new Error('Descricao do item obrigatoria');
+        }
+        assertMaxLength(nextRow.name, INVENTORY_DESCRIPTION_MAX_LENGTH, 'Descricao do item');
+        if (!nextRow.status) nextRow.status = 'disponivel';
+        if (!nextRow.location) nextRow.location = 'DOCA-01';
+        if (nextRow.quantity === null || nextRow.quantity === undefined || Number.isNaN(Number(nextRow.quantity))) {
+          nextRow.quantity = 0;
+        }
+        if (!nextRow.warehouse_id) nextRow.warehouse_id = 'ARMZ28';
+      }
+      if (table === 'vendors') {
+        vendorLocalSequence += 1;
+        const defaultId = `VEN-${Date.now()}-${String(index + 1 + vendorLocalSequence).padStart(4, '0')}`;
+        const normalizedVendor = normalizeVendorRow(nextRow, defaultId);
+        Object.keys(nextRow).forEach((key) => {
+          if (!(key in normalizedVendor)) delete nextRow[key];
+        });
+        Object.assign(nextRow, normalizedVendor);
+      }
+      if (table === 'cyclic_counts') {
+        if (!nextRow.id) nextRow.id = crypto.randomUUID();
+        if (!nextRow.status) nextRow.status = 'pendente';
+      }
+      if (table === 'movements' && !nextRow.id) {
+        nextRow.id = crypto.randomUUID();
+      }
+      if (table === 'fleet_vehicles') {
+        nextRow.placa = String(nextRow.placa || '')
+          .trim()
+          .toUpperCase();
+        if (!nextRow.placa) {
+          throw new Error('Placa obrigatoria para cadastro de veiculo de frota');
+        }
+        if (nextRow.km_atual === null || nextRow.km_atual === undefined || Number.isNaN(Number(nextRow.km_atual))) {
+          nextRow.km_atual = 0;
+        }
+        if (nextRow.km_anterior === null || nextRow.km_anterior === undefined || Number.isNaN(Number(nextRow.km_anterior))) {
+          nextRow.km_anterior = 0;
+        }
+        if (nextRow.km_prox_manutencao === null || nextRow.km_prox_manutencao === undefined || Number.isNaN(Number(nextRow.km_prox_manutencao))) {
+          nextRow.km_prox_manutencao = 0;
+        }
+        if (!nextRow.gestao_multa) nextRow.gestao_multa = 'NAO';
+        if (!nextRow.created_at) nextRow.created_at = new Date().toISOString();
+      }
+      if (table === 'fleet_people') {
+        nextRow.cpf = String(nextRow.cpf || '').replace(/\D/g, '');
+        if (!nextRow.cpf) {
+          throw new Error('CPF obrigatorio para cadastro de pessoa da frota');
+        }
+        if (!nextRow.status) nextRow.status = 'ATIVO';
+        if (!nextRow.created_at) nextRow.created_at = new Date().toISOString();
+      }
+      if (table === 'fleet_fines') {
+        if (!nextRow.id) nextRow.id = crypto.randomUUID();
+        nextRow.placa = String(nextRow.placa || '').trim().toUpperCase();
+        if (!nextRow.status) nextRow.status = 'PENDENTE';
+        if (!nextRow.created_at) nextRow.created_at = new Date().toISOString();
+      }
+      if (table === 'fleet_tachograph_checks') {
+        if (!nextRow.id) nextRow.id = crypto.randomUUID();
+        nextRow.placa = String(nextRow.placa || '').trim().toUpperCase();
+        if (!nextRow.status) nextRow.status = 'REGULAR';
+        if (!nextRow.created_at) nextRow.created_at = new Date().toISOString();
+      }
+      if (table === 'fleet_rntrc_records') {
+        if (!nextRow.id) nextRow.id = crypto.randomUUID();
+        if (!nextRow.status) nextRow.status = 'ATIVO';
+        if (!nextRow.created_at) nextRow.created_at = new Date().toISOString();
+      }
+      if (table === 'fleet_fiscal_obligations') {
+        if (!nextRow.id) nextRow.id = crypto.randomUUID();
+        nextRow.placa = String(nextRow.placa || '').trim().toUpperCase();
+        if (!nextRow.status) nextRow.status = 'PENDENTE';
+        if (!nextRow.created_at) nextRow.created_at = new Date().toISOString();
+      }
+      return nextRow;
+    });
+  } catch (err) {
+    const message = err instanceof Error ? err.message : 'Dados invalidos para criacao';
+    res.status(400).json({ data: null, error: message });
+    return;
+  }
+
+  if (table === 'vendors') {
+    try {
+      if (!dbConnected) {
+        const existingRows = normalizeRowsByTable('vendors', readJson('vendors'));
+        ensureNoVendorDuplicatesInMemory(preparedRows, existingRows);
+
+        let maxVendorId = existingRows.reduce((maxValue, row) => {
+          const current = Number(row?.id_fornecedor);
+          return Number.isFinite(current) ? Math.max(maxValue, current) : maxValue;
+        }, 0);
+
+        preparedRows.forEach((row) => {
+          const parsed = Number(row?.id_fornecedor);
+          if (Number.isFinite(parsed) && parsed > 0) return;
+          maxVendorId += 1;
+          row.id_fornecedor = maxVendorId;
+        });
+      } else {
+        ensureNoVendorDuplicatesInMemory(preparedRows, []);
+        for (const row of preparedRows) {
+          const conflict = await findVendorConflictInDb(pool, row);
+          if (conflict) {
+            throw new Error(
+              `Fornecedor ja cadastrado (${conflict.razao_social || conflict.name || conflict.cnpj || conflict.id})`
+            );
+          }
+        }
+      }
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Dados de fornecedor invalidos';
+      res.status(409).json({ data: null, error: message });
+      return;
     }
-    if (table === 'movements' && !nextRow.id) {
-      nextRow.id = crypto.randomUUID();
+  }
+
+  if (table === 'inventory') {
+    try {
+      const batchSkus = new Set();
+      for (const row of preparedRows) {
+        const sku = String(row?.sku || '').trim().toUpperCase();
+        if (!sku) continue;
+        if (batchSkus.has(sku)) {
+          throw new Error(`Codigo item (SKU) duplicado no lote: ${sku}`);
+        }
+        batchSkus.add(sku);
+      }
+
+      if (!dbConnected) {
+        const existingSkus = new Set(
+          normalizeRowsByTable('inventory', readJson('inventory'))
+            .map((row) => String(row?.sku || '').trim().toUpperCase())
+            .filter(Boolean)
+        );
+        for (const sku of batchSkus) {
+          if (existingSkus.has(sku)) {
+            throw new Error(`Codigo item (SKU) ja cadastrado: ${sku}`);
+          }
+        }
+      } else {
+        const skuList = Array.from(batchSkus);
+        if (skuList.length > 0) {
+          const conflictResult = await pool.query(
+            'SELECT sku FROM inventory WHERE sku = ANY($1::text[]) LIMIT 1',
+            [skuList]
+          );
+          const conflictSku = conflictResult.rows?.[0]?.sku;
+          if (conflictSku) {
+            throw new Error(`Codigo item (SKU) ja cadastrado: ${conflictSku}`);
+          }
+        }
+      }
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Dados de item invalidos';
+      res.status(409).json({ data: null, error: message });
+      return;
     }
-    return nextRow;
-  });
+  }
 
   if (!dbConnected) {
     const currentData = readJson(table);
@@ -1645,6 +2423,7 @@ app.post('/:table', authenticate, async (req, res) => {
   try {
     client = await pool.connect();
     await client.query('BEGIN');
+    await setDbAuditContext(client, { actor, actorId, module: table });
 
     const insertedRows = [];
     const preparedRowsForDb = preparedRows.map((row) => normalizeRowForDb(table, row));
@@ -1663,11 +2442,9 @@ app.post('/:table', authenticate, async (req, res) => {
       insertedRows.push(result.rows[0]);
     }
 
-    await client.query('COMMIT');
-
     const normalized = normalizeRowsByTable(table, insertedRows);
 
-    if (table !== 'audit_logs') {
+    if (table !== 'audit_logs' && !DB_TRIGGER_AUDITED_TABLES.has(table)) {
       const auditEntries = normalized.map((row) =>
         buildAuditLog({
           module: table,
@@ -1685,9 +2462,12 @@ app.post('/:table', authenticate, async (req, res) => {
       await persistAuditLogs(auditEntries, client);
     }
 
+    await client.query('COMMIT');
+
     res.json({ data: sanitizeResponse(Array.isArray(payload) ? normalized : normalized[0]), error: null });
   } catch (err) {
     if (client) await client.query('ROLLBACK');
+    if (sendUniqueConstraintConflict(res, err)) return;
     markDbDisconnectedIfNeeded(err);
     sendServerError(res, err);
   } finally {
@@ -1705,6 +2485,18 @@ app.patch('/:table', authenticate, async (req, res) => {
     return;
   }
 
+  if (WRITE_RESTRICTED_TABLES.has(table)) {
+    res.status(403).json({
+      data: null,
+      error: 'Escrita bloqueada nesta tabela. Use a base central em fleet_vehicles.',
+    });
+    return;
+  }
+
+  if (!ensureFleetWriteSourceModule(table, req, res)) {
+    return;
+  }
+
   if (!req.body || typeof req.body !== 'object' || Array.isArray(req.body)) {
     res.status(400).json({ data: null, error: 'Payload invalido para update' });
     return;
@@ -1725,6 +2517,87 @@ app.patch('/:table', authenticate, async (req, res) => {
     updates.password = ensurePasswordHash(updates.password);
   }
 
+  if (table === 'inventory') {
+    if ('sku' in updates) {
+      const normalizedSku = normalizeWhitespace(updates.sku).toUpperCase();
+      if (!normalizedSku) {
+        res.status(400).json({ data: null, error: 'Codigo item (SKU) obrigatorio' });
+        return;
+      }
+      updates.sku = normalizedSku;
+    }
+
+    if ('name' in updates) {
+      const normalizedName = normalizeWhitespace(updates.name);
+      if (!normalizedName) {
+        res.status(400).json({ data: null, error: 'Descricao do item obrigatoria' });
+        return;
+      }
+      if (normalizedName.length > INVENTORY_DESCRIPTION_MAX_LENGTH) {
+        res.status(400).json({
+          data: null,
+          error: `Descricao do item deve ter no maximo ${INVENTORY_DESCRIPTION_MAX_LENGTH} caracteres`,
+        });
+        return;
+      }
+      updates.name = normalizedName;
+    }
+  }
+
+  if (table === 'vendors') {
+    if ('id_fornecedor' in updates) {
+      delete updates.id_fornecedor;
+    }
+
+    if ('razao_social' in updates || 'name' in updates) {
+      const normalizedName = normalizeWhitespace(updates.razao_social || updates.name);
+      if (!normalizedName) {
+        res.status(400).json({ data: null, error: 'Razao social e obrigatoria' });
+        return;
+      }
+      if (normalizedName.length > VENDOR_RAZAO_SOCIAL_MAX_LENGTH) {
+        res.status(400).json({
+          data: null,
+          error: `Razao social deve ter no maximo ${VENDOR_RAZAO_SOCIAL_MAX_LENGTH} caracteres`,
+        });
+        return;
+      }
+      updates.razao_social = normalizedName;
+      updates.name = normalizedName;
+    }
+
+    if ('nome_fantasia' in updates) {
+      const normalizedFantasy = normalizeWhitespace(updates.nome_fantasia) || null;
+      if (normalizedFantasy && normalizedFantasy.length > VENDOR_NOME_FANTASIA_MAX_LENGTH) {
+        res.status(400).json({
+          data: null,
+          error: `Nome fantasia deve ter no maximo ${VENDOR_NOME_FANTASIA_MAX_LENGTH} caracteres`,
+        });
+        return;
+      }
+      updates.nome_fantasia = normalizedFantasy;
+    }
+
+    if ('telefone' in updates || 'contact' in updates) {
+      const normalizedPhone = normalizePhone(updates.telefone || updates.contact);
+      updates.telefone = normalizedPhone || null;
+      updates.contact = normalizedPhone || updates.contact || null;
+    }
+
+    if ('cnpj' in updates) {
+      const normalizedCnpj = normalizeCnpj(updates.cnpj);
+      if (!normalizedCnpj || !isValidCnpj(normalizedCnpj)) {
+        res.status(400).json({ data: null, error: 'CNPJ invalido' });
+        return;
+      }
+      updates.cnpj = normalizedCnpj;
+    }
+
+    if ('status' in updates) {
+      updates.status = normalizeVendorStatus(updates.status);
+    }
+  }
+
   const filters = getFiltersFromQuery(req.query);
   if (Object.keys(filters).length === 0) {
     res.status(400).json({ data: null, error: 'Filtro obrigatorio para update' });
@@ -1755,6 +2628,18 @@ app.patch('/:table', authenticate, async (req, res) => {
       return;
     }
 
+    if (table === 'vendors') {
+      try {
+        const remainingRows = currentData.filter((row) => !isRowMatch(row, filters));
+        const ignoreIds = new Set(updatedRows.map((row) => String(row?.id || '')));
+        ensureNoVendorDuplicatesInMemory(updatedRows, remainingRows, ignoreIds);
+      } catch (err) {
+        const message = err instanceof Error ? err.message : 'Conflito de fornecedor';
+        res.status(409).json({ data: null, error: message });
+        return;
+      }
+    }
+
     writeJson(table, nextData);
 
     if (table !== 'audit_logs') {
@@ -1782,7 +2667,12 @@ app.patch('/:table', authenticate, async (req, res) => {
     return;
   }
 
+  let client;
   try {
+    client = await pool.connect();
+    await client.query('BEGIN');
+    await setDbAuditContext(client, { actor, actorId, module: table });
+
     const dbUpdates = normalizeRowForDb(table, updates);
     const updateEntries = Object.entries(dbUpdates);
     const filterEntries = Object.entries(filters);
@@ -1801,19 +2691,36 @@ app.patch('/:table', authenticate, async (req, res) => {
     ];
 
     const beforeQuery = `SELECT * FROM ${quoteIdentifier(table)} WHERE ${beforeWhereClause}`;
-    const beforeResult = await pool.query(beforeQuery, filterEntries.map(([, value]) => coerceValue(value)));
+    const beforeResult = await client.query(beforeQuery, filterEntries.map(([, value]) => coerceValue(value)));
+
+    if (table === 'vendors') {
+      const beforeRows = normalizeRowsByTable(table, beforeResult.rows);
+      const previewRows = beforeRows.map((row) => normalizeVendorRow({ ...row, ...updates }, row.id));
+      for (const row of previewRows) {
+        const conflict = await findVendorConflictInDb(client, row, row.id);
+        if (conflict) {
+          await client.query('ROLLBACK');
+          res.status(409).json({
+            data: null,
+            error: `Fornecedor ja cadastrado (${conflict.razao_social || conflict.name || conflict.cnpj || conflict.id})`,
+          });
+          return;
+        }
+      }
+    }
 
     const query = `UPDATE ${quoteIdentifier(table)} SET ${setClause} WHERE ${whereClause} RETURNING *`;
-    const result = await pool.query(query, values);
+    const result = await client.query(query, values);
 
     if (result.rows.length === 0) {
+      await client.query('ROLLBACK');
       res.status(404).json({ data: null, error: 'Nenhum registro encontrado' });
       return;
     }
 
     const normalizedRows = normalizeRowsByTable(table, result.rows);
 
-    if (table !== 'audit_logs') {
+    if (table !== 'audit_logs' && !DB_TRIGGER_AUDITED_TABLES.has(table)) {
       const beforeRows = normalizeRowsByTable(table, beforeResult.rows);
       const beforeMap = new Map(beforeRows.map((row) => [getEntityId(table, row), row]));
       const auditEntries = normalizedRows.map((row) =>
@@ -1833,13 +2740,24 @@ app.patch('/:table', authenticate, async (req, res) => {
           },
         })
       );
-      await persistAuditLogs(auditEntries, pool);
+      await persistAuditLogs(auditEntries, client);
     }
 
+    await client.query('COMMIT');
     res.json({ data: sanitizeResponse(normalizedRows), error: null });
   } catch (err) {
+    if (client) {
+      try {
+        await client.query('ROLLBACK');
+      } catch {
+        // noop
+      }
+    }
+    if (sendUniqueConstraintConflict(res, err)) return;
     markDbDisconnectedIfNeeded(err);
     sendServerError(res, err);
+  } finally {
+    if (client) client.release();
   }
 });
 
@@ -1853,6 +2771,18 @@ app.delete('/:table', authenticate, async (req, res) => {
     return;
   }
 
+  if (WRITE_RESTRICTED_TABLES.has(table)) {
+    res.status(403).json({
+      data: null,
+      error: 'Escrita bloqueada nesta tabela. Use a base central em fleet_vehicles.',
+    });
+    return;
+  }
+
+  if (!ensureFleetWriteSourceModule(table, req, res)) {
+    return;
+  }
+
   const filters = getFiltersFromQuery(req.query);
   if (Object.keys(filters).length === 0) {
     res.status(400).json({ data: null, error: 'Filtro obrigatorio para delete' });
@@ -1898,22 +2828,28 @@ app.delete('/:table', authenticate, async (req, res) => {
     return;
   }
 
+  let client;
   try {
+    client = await pool.connect();
+    await client.query('BEGIN');
+    await setDbAuditContext(client, { actor, actorId, module: table });
+
     const filterEntries = Object.entries(filters);
     const whereClause = filterEntries.map(([column], index) => `${quoteIdentifier(column)} = $${index + 1}`).join(' AND ');
     const values = filterEntries.map(([, value]) => coerceValue(value));
 
     const query = `DELETE FROM ${quoteIdentifier(table)} WHERE ${whereClause} RETURNING *`;
-    const result = await pool.query(query, values);
+    const result = await client.query(query, values);
 
     if (result.rows.length === 0) {
+      await client.query('ROLLBACK');
       res.status(404).json({ data: null, error: 'Nenhum registro encontrado' });
       return;
     }
 
     const normalizedRows = normalizeRowsByTable(table, result.rows);
 
-    if (table !== 'audit_logs') {
+    if (table !== 'audit_logs' && !DB_TRIGGER_AUDITED_TABLES.has(table)) {
       const auditEntries = normalizedRows.map((row) =>
         buildAuditLog({
           module: table,
@@ -1928,16 +2864,32 @@ app.delete('/:table', authenticate, async (req, res) => {
           meta: { filters },
         })
       );
-      await persistAuditLogs(auditEntries, pool);
+      await persistAuditLogs(auditEntries, client);
     }
 
+    await client.query('COMMIT');
     res.json({ data: sanitizeResponse(normalizedRows), error: null });
   } catch (err) {
+    if (client) {
+      try {
+        await client.query('ROLLBACK');
+      } catch {
+        // noop
+      }
+    }
+    if (sendUniqueConstraintConflict(res, err)) return;
     markDbDisconnectedIfNeeded(err);
     sendServerError(res, err);
+  } finally {
+    if (client) client.release();
   }
 });
 
+void runPurchaseOrdersRetentionCleanup();
+setInterval(() => {
+  void runPurchaseOrdersRetentionCleanup();
+}, PO_RETENTION_CLEANUP_INTERVAL_MS);
+
 app.listen(port, () => {
   console.log(`API running on port ${port}`);
   if (!dbConnected) console.log('JSON contingency mode active');
